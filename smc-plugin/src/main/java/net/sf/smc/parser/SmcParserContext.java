/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : SmcParser.sm
 */


/*
 * The contents of this file are subject to the Mozilla Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code is State Machine Compiler (SMC).
 *
 * The Initial Developer of the Original Code is Charles W. Rapp.
 * Portions created by Charles W. Rapp are
 * Copyright (C) 2000 - 2005, 2008. Charles W. Rapp.
 * All Rights Reserved.
 *
 * Contributor(s):
 *   Eitan Suez contributed examples/Ant.
 *   (Name withheld) contributed the C# code generation and
 *   examples/C#.
 *   Francois Perrad contributed the Python code generation and
 *   examples/Python, Perl code generation and examples/Perl,
 *   Ruby code generation and examples/Ruby, Lua code generation
 *   and examples/Lua, Groovy code generation and examples/Groovy.
 *   Chris Liscio contributed the Objective-C code generation
 *   and examples/ObjC.
 *
 * smcParser --
 *
 *  This state machine defines the  state machine language.
 *
 * RCS ID
 * $Id: SmcParser.sm,v 1.7 2010/03/05 21:29:54 fperrad Exp $
 *
 * CHANGE LOG
 * $Log: SmcParser.sm,v $
 * Revision 1.7  2010/03/05 21:29:54  fperrad
 * Allows property with Groovy, Lua, Perl, Python, Ruby & Scala
 *
 * Revision 1.6  2010/03/03 19:18:41  fperrad
 * fix property with Graph & Table
 *
 * Revision 1.5  2009/09/12 21:44:49  kgreg99
 * Implemented feature req. #2718941 - user defined generated class name.
 * A new statement was added to the syntax: %fsmclass class_name
 * It is optional. If not used, generated class is called as before "XxxContext" where Xxx is context class name as entered via %class statement.
 * If used, generated class is called asrequested.
 * Following language generators are touched:
 * c, c++, java, c#, objc, lua, groovy, scala, tcl, VB
 * This feature is not tested yet !
 * Maybe it will be necessary to modify also the output file name.
 *
 * Revision 1.4  2009/04/11 13:11:13  cwrapp
 * Corrected raw mode 3 to handle multiple argument template/generic declarations.
 *
 * Revision 1.3  2009/03/27 09:41:47  cwrapp
 * Added F. Perrad changes back in.
 *
 * Revision 1.2  2009/03/03 17:28:53  kgreg99
 * 1. Bugs resolved:
 * #2657779 - modified SmcParser.sm and SmcParserContext.java
 * #2648516 - modified SmcCSharpGenerator.java
 * #2648472 - modified SmcSyntaxChecker.java
 * #2648469 - modified SmcMap.java
 *
 * Revision 1.1  2009/03/01 18:20:42  cwrapp
 * Preliminary v. 6.0.0 commit.
 *
 * Revision 1.21  2008/08/16 14:31:37  fperrad
 * + detabify
 *
 * Revision 1.20  2008/04/22 16:05:24  fperrad
 * - add PHP language (patch from Toni Arnold)
 *
 * Revision 1.19  2008/01/22 08:56:55  fperrad
 * - fix : allows Perl parameter with graph generation
 *
 * Revision 1.18  2007/11/19 18:53:21  fperrad
 * + add : jump syntax
 *   jump uses the same syntax as push,
 *   allows transition between states of different maps but without stacking a return context.
 *
 * Revision 1.17  2007/07/16 06:28:06  fperrad
 * + Added Groovy generator.
 *
 * Revision 1.16  2007/02/21 13:56:16  cwrapp
 * Moved Java code to release 1.5.0
 *
 * Revision 1.15  2007/01/15 00:23:51  cwrapp
 * Release 4.4.0 initial commit.
 *
 * Revision 1.14  2007/01/03 15:23:05  fperrad
 * + Added Lua generator.
 *
 * Revision 1.13  2006/09/16 15:04:29  cwrapp
 * Initial v. 4.3.3 check-in.
 *
 * Revision 1.12  2006/07/11 18:17:01  cwrapp
 * Removed errors regarding percent keywords.
 *
 * Revision 1.11  2006/04/22 12:45:26  cwrapp
 * Version 4.3.1
 *
 * Revision 1.10  2005/09/14 01:51:33  cwrapp
 * Changes in release 4.2.0:
 * New features:
 *
 * None.
 *
 * Fixed the following bugs:
 *
 * + (Java) -java broken due to an untested minor change.
 *
 * Revision 1.9  2005/08/26 15:21:34  cwrapp
 * Final commit for release 4.2.0. See README.txt for more information.
 *
 * Revision 1.8  2005/07/07 12:11:56  fperrad
 * Add a new token '$' for Perl language.
 * The type of parameter is optional for Python, Per & Ruby.
 *
 * Revision 1.7  2005/06/30 10:44:23  cwrapp
 * Added %access keyword which allows developers to set the generate Context
 * class' accessibility level in Java and C#.
 *
 * Revision 1.6  2005/05/28 19:28:42  cwrapp
 * Moved to visitor pattern.
 *
 * Revision 1.5  2005/02/21 15:37:52  charlesr
 * Added Francois Perrad to Contributors section for Python work.
 *
 * Revision 1.4  2005/02/21 15:21:21  charlesr
 * Added -graph target as allowing %include, %declare and %import.
 *
 * Revision 1.3  2005/02/03 17:06:21  charlesr
 * SmcParser.warning() and .error() methods now take a line
 * number argument. All calls to these method within the
 * parser's FSM have been modified.
 *
 * Revision 1.2  2004/09/06 16:41:32  charlesr
 * Added "property = value" syntax. Added C# support.
 *
 * Revision 1.1  2004/05/31 13:56:34  charlesr
 * Added support for VB.net code generation.
 *
 * Revision 1.0  2003/12/14 21:06:00  charlesr
 * Initial revision
 *
 */


package net.sf.smc.parser;

import java.io.PrintStream;
import java.util.List;

import net.sf.smc.model.SmcAction;
import net.sf.smc.model.SmcElement.TransType;
import net.sf.smc.model.SmcParameter;
import net.sf.smc.parser.SmcParser.TargetLanguage;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SmcParserContext
    extends statemap.FSMContext
    implements java.io.Serializable
{
private final static Logger log = LoggerFactory.getLogger(SmcParserContext.class);
//---------------------------------------------------------------
// Member methods.
//

    public Logger getLog() {return log;}

    public SmcParserContext(SmcParser owner)
    {
        super (ParserMap.Start);

        _owner = owner;
    }

    public SmcParserContext(SmcParser owner, SmcParserState initState)
    {
        super (initState);

        _owner = owner;
    }

    public synchronized void enterStartState()
    {
        getState().Entry(this);
        return;
    }

    public synchronized void ACCESS(SmcLexer.Token token)
    {
        _transition = "ACCESS";
        getState().ACCESS(this, token);
        _transition = "";
        return;
    }

    public synchronized void CLASS_NAME(SmcLexer.Token token)
    {
        _transition = "CLASS_NAME";
        getState().CLASS_NAME(this, token);
        _transition = "";
        return;
    }

    public synchronized void COLON(SmcLexer.Token token)
    {
        _transition = "COLON";
        getState().COLON(this, token);
        _transition = "";
        return;
    }

    public synchronized void COMMA(SmcLexer.Token token)
    {
        _transition = "COMMA";
        getState().COMMA(this, token);
        _transition = "";
        return;
    }

    public synchronized void DECLARE(SmcLexer.Token token)
    {
        _transition = "DECLARE";
        getState().DECLARE(this, token);
        _transition = "";
        return;
    }

    public synchronized void DOLLAR(SmcLexer.Token token)
    {
        _transition = "DOLLAR";
        getState().DOLLAR(this, token);
        _transition = "";
        return;
    }

    public synchronized void ENTRY(SmcLexer.Token token)
    {
        _transition = "ENTRY";
        getState().ENTRY(this, token);
        _transition = "";
        return;
    }

    public synchronized void EOD(SmcLexer.Token token)
    {
        _transition = "EOD";
        getState().EOD(this, token);
        _transition = "";
        return;
    }

    public synchronized void EQUAL(SmcLexer.Token token)
    {
        _transition = "EQUAL";
        getState().EQUAL(this, token);
        _transition = "";
        return;
    }

    public synchronized void EXIT(SmcLexer.Token token)
    {
        _transition = "EXIT";
        getState().EXIT(this, token);
        _transition = "";
        return;
    }

    public synchronized void FSM_CLASS_NAME(SmcLexer.Token token)
    {
        _transition = "FSM_CLASS_NAME";
        getState().FSM_CLASS_NAME(this, token);
        _transition = "";
        return;
    }

    public synchronized void HEADER_FILE(SmcLexer.Token token)
    {
        _transition = "HEADER_FILE";
        getState().HEADER_FILE(this, token);
        _transition = "";
        return;
    }

    public synchronized void IMPORT(SmcLexer.Token token)
    {
        _transition = "IMPORT";
        getState().IMPORT(this, token);
        _transition = "";
        return;
    }

    public synchronized void INCLUDE_FILE(SmcLexer.Token token)
    {
        _transition = "INCLUDE_FILE";
        getState().INCLUDE_FILE(this, token);
        _transition = "";
        return;
    }

    public synchronized void JUMP(SmcLexer.Token token)
    {
        _transition = "JUMP";
        getState().JUMP(this, token);
        _transition = "";
        return;
    }

    public synchronized void LEFT_BRACE(SmcLexer.Token token)
    {
        _transition = "LEFT_BRACE";
        getState().LEFT_BRACE(this, token);
        _transition = "";
        return;
    }

    public synchronized void LEFT_BRACKET(SmcLexer.Token token)
    {
        _transition = "LEFT_BRACKET";
        getState().LEFT_BRACKET(this, token);
        _transition = "";
        return;
    }

    public synchronized void LEFT_PAREN(SmcLexer.Token token)
    {
        _transition = "LEFT_PAREN";
        getState().LEFT_PAREN(this, token);
        _transition = "";
        return;
    }

    public synchronized void MAP_NAME(SmcLexer.Token token)
    {
        _transition = "MAP_NAME";
        getState().MAP_NAME(this, token);
        _transition = "";
        return;
    }

    public synchronized void PACKAGE_NAME(SmcLexer.Token token)
    {
        _transition = "PACKAGE_NAME";
        getState().PACKAGE_NAME(this, token);
        _transition = "";
        return;
    }

    public synchronized void POP(SmcLexer.Token token)
    {
        _transition = "POP";
        getState().POP(this, token);
        _transition = "";
        return;
    }

    public synchronized void PUSH(SmcLexer.Token token)
    {
        _transition = "PUSH";
        getState().PUSH(this, token);
        _transition = "";
        return;
    }

    public synchronized void RIGHT_BRACE(SmcLexer.Token token)
    {
        _transition = "RIGHT_BRACE";
        getState().RIGHT_BRACE(this, token);
        _transition = "";
        return;
    }

    public synchronized void RIGHT_PAREN(SmcLexer.Token token)
    {
        _transition = "RIGHT_PAREN";
        getState().RIGHT_PAREN(this, token);
        _transition = "";
        return;
    }

    public synchronized void SEMICOLON(SmcLexer.Token token)
    {
        _transition = "SEMICOLON";
        getState().SEMICOLON(this, token);
        _transition = "";
        return;
    }

    public synchronized void SLASH(SmcLexer.Token token)
    {
        _transition = "SLASH";
        getState().SLASH(this, token);
        _transition = "";
        return;
    }

    public synchronized void SOURCE(SmcLexer.Token token)
    {
        _transition = "SOURCE";
        getState().SOURCE(this, token);
        _transition = "";
        return;
    }

    public synchronized void START_STATE(SmcLexer.Token token)
    {
        _transition = "START_STATE";
        getState().START_STATE(this, token);
        _transition = "";
        return;
    }

    public synchronized void WORD(SmcLexer.Token token)
    {
        _transition = "WORD";
        getState().WORD(this, token);
        _transition = "";
        return;
    }

    public synchronized void actionsDone(List<SmcAction> actions, int lineNumber)
    {
        _transition = "actionsDone";
        getState().actionsDone(this, actions, lineNumber);
        _transition = "";
        return;
    }

    public synchronized void actionsError()
    {
        _transition = "actionsError";
        getState().actionsError(this);
        _transition = "";
        return;
    }

    public synchronized void argsDone(List<String> args)
    {
        _transition = "argsDone";
        getState().argsDone(this, args);
        _transition = "";
        return;
    }

    public synchronized void argsError()
    {
        _transition = "argsError";
        getState().argsError(this);
        _transition = "";
        return;
    }

    public synchronized void paramsDone(List<SmcParameter> params, int lineNumber)
    {
        _transition = "paramsDone";
        getState().paramsDone(this, params, lineNumber);
        _transition = "";
        return;
    }

    public synchronized void paramsError(List<SmcParameter> params, int lineNumber)
    {
        _transition = "paramsError";
        getState().paramsError(this, params, lineNumber);
        _transition = "";
        return;
    }

    public SmcParserState valueOf(int stateId)
        throws ArrayIndexOutOfBoundsException
    {
        return (_States[stateId]);
    }

    public SmcParserState getState()
        throws statemap.StateUndefinedException
    {
        if (_state == null)
        {
            throw(
                new statemap.StateUndefinedException());
        }

        return ((SmcParserState) _state);
    }

    protected SmcParser getOwner()
    {
        return (_owner);
    }

    public void setOwner(SmcParser owner)
    {
        if (owner == null)
        {
            throw (
                new NullPointerException(
                    "null owner"));
        }
        else
        {
            _owner = owner;
        }

        return;
    }

//---------------------------------------------------------------
// Member data.
//

    transient private SmcParser _owner;
    transient private static SmcParserState[] _States =
    {
        ParserMap.Start,
        ParserMap.Context,
        ParserMap.StartState,
        ParserMap.HeaderFile,
        ParserMap.IncludeFile,
        ParserMap.Package,
        ParserMap.FsmClassName,
        ParserMap.Import,
        ParserMap.Declare,
        ParserMap.Access,
        ParserMap.StartError,
        ParserMap.MapStart,
        ParserMap.MapStartError,
        ParserMap.MapName,
        ParserMap.MapStates,
        ParserMap.MapStatesError,
        ParserMap.States,
        ParserMap.StateStart,
        ParserMap.StateStartError,
        ParserMap.EntryStart,
        ParserMap.EntryEnd,
        ParserMap.ExitStart,
        ParserMap.ExitEnd,
        ParserMap.Transitions,
        ParserMap.TransError,
        ParserMap.TransStart,
        ParserMap.TransStartError,
        ParserMap.TransParams,
        ParserMap.TransNext,
        ParserMap.TransNextError,
        ParserMap.TransGuard,
        ParserMap.EndState,
        ParserMap.EndStateError,
        ParserMap.SimpleTrans,
        ParserMap.PushTransition,
        ParserMap.PushStart,
        ParserMap.PushError,
        ParserMap.PushMap,
        ParserMap.PushEnd,
        ParserMap.JumpStart,
        ParserMap.JumpError,
        ParserMap.JumpMap,
        ParserMap.JumpEnd,
        ParserMap.PopStart,
        ParserMap.PopError,
        ParserMap.PopAction,
        ParserMap.PopArgs,
        ParserMap.PopArgsEnd,
        ParserMap.ActionStart,
        ParserMap.ActionEnd,
        ParserMap.ActionStartError,
        ParamMap.Start,
        ParamMap.Dollar,
        ParamMap.ParamSeparator,
        ParamMap.ParamType,
        ParamMap.NextParam,
        ParamMap.Error,
        ActionMap.Start,
        ActionMap.ActionName,
        ActionMap.ActionArgs,
        ActionMap.ActionEnd,
        ActionMap.PropertyAssignment,
        ActionMap.ActionError,
        ArgsMap.Start,
        ArgsMap.NextArg,
        ArgsMap.Error
    };

    @SuppressWarnings("serial")
    public static abstract class SmcParserState
        extends statemap.State
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected SmcParserState(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context) {}
        protected void Exit(SmcParserContext context) {}

        protected void ACCESS(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void CLASS_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void COLON(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void COMMA(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void DECLARE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void DOLLAR(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void ENTRY(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void EOD(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void EQUAL(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void EXIT(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void FSM_CLASS_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void HEADER_FILE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void IMPORT(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void INCLUDE_FILE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void JUMP(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void LEFT_BRACKET(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void PACKAGE_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void POP(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void RIGHT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void SEMICOLON(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void SLASH(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void START_STATE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void actionsDone(SmcParserContext context, List<SmcAction> actions, int lineNumber)
        {
            Default(context);
        }

        protected void actionsError(SmcParserContext context)
        {
            Default(context);
        }

        protected void argsDone(SmcParserContext context, List<String> args)
        {
            Default(context);
        }

        protected void argsError(SmcParserContext context)
        {
            Default(context);
        }

        protected void paramsDone(SmcParserContext context, List<SmcParameter> params, int lineNumber)
        {
            Default(context);
        }

        protected void paramsError(SmcParserContext context, List<SmcParameter> params, int lineNumber)
        {
            Default(context);
        }

        protected void Default(SmcParserContext context)
        {
            if (log.isTraceEnabled())
            {
                log.trace(
                    "TRANSITION   : Default [" + context.getName() + "]");
            }

            throw (
                new statemap.TransitionUndefinedException(
                    "State: " +
                    context.getState().getName() +
                    ", Transition: " +
                    context.getTransition()));
        }

    //-----------------------------------------------------------
    // Member data.
    //
    }

    public static abstract class ParserMap
    {
    //-----------------------------------------------------------
    // Member methods.
    //

    //-----------------------------------------------------------
    // Member data.
    //

        //-------------------------------------------------------
        // Constants.
        //
        public static final ParserMap_Start Start =
            new ParserMap_Start("ParserMap.Start", 0);
        public static final ParserMap_Context Context =
            new ParserMap_Context("ParserMap.Context", 1);
        public static final ParserMap_StartState StartState =
            new ParserMap_StartState("ParserMap.StartState", 2);
        public static final ParserMap_HeaderFile HeaderFile =
            new ParserMap_HeaderFile("ParserMap.HeaderFile", 3);
        public static final ParserMap_IncludeFile IncludeFile =
            new ParserMap_IncludeFile("ParserMap.IncludeFile", 4);
        public static final ParserMap_Package Package =
            new ParserMap_Package("ParserMap.Package", 5);
        public static final ParserMap_FsmClassName FsmClassName =
            new ParserMap_FsmClassName("ParserMap.FsmClassName", 6);
        public static final ParserMap_Import Import =
            new ParserMap_Import("ParserMap.Import", 7);
        public static final ParserMap_Declare Declare =
            new ParserMap_Declare("ParserMap.Declare", 8);
        public static final ParserMap_Access Access =
            new ParserMap_Access("ParserMap.Access", 9);
        public static final ParserMap_StartError StartError =
            new ParserMap_StartError("ParserMap.StartError", 10);
        public static final ParserMap_MapStart MapStart =
            new ParserMap_MapStart("ParserMap.MapStart", 11);
        public static final ParserMap_MapStartError MapStartError =
            new ParserMap_MapStartError("ParserMap.MapStartError", 12);
        public static final ParserMap_MapName MapName =
            new ParserMap_MapName("ParserMap.MapName", 13);
        public static final ParserMap_MapStates MapStates =
            new ParserMap_MapStates("ParserMap.MapStates", 14);
        public static final ParserMap_MapStatesError MapStatesError =
            new ParserMap_MapStatesError("ParserMap.MapStatesError", 15);
        public static final ParserMap_States States =
            new ParserMap_States("ParserMap.States", 16);
        public static final ParserMap_StateStart StateStart =
            new ParserMap_StateStart("ParserMap.StateStart", 17);
        public static final ParserMap_StateStartError StateStartError =
            new ParserMap_StateStartError("ParserMap.StateStartError", 18);
        public static final ParserMap_EntryStart EntryStart =
            new ParserMap_EntryStart("ParserMap.EntryStart", 19);
        public static final ParserMap_EntryEnd EntryEnd =
            new ParserMap_EntryEnd("ParserMap.EntryEnd", 20);
        public static final ParserMap_ExitStart ExitStart =
            new ParserMap_ExitStart("ParserMap.ExitStart", 21);
        public static final ParserMap_ExitEnd ExitEnd =
            new ParserMap_ExitEnd("ParserMap.ExitEnd", 22);
        public static final ParserMap_Transitions Transitions =
            new ParserMap_Transitions("ParserMap.Transitions", 23);
        public static final ParserMap_TransError TransError =
            new ParserMap_TransError("ParserMap.TransError", 24);
        public static final ParserMap_TransStart TransStart =
            new ParserMap_TransStart("ParserMap.TransStart", 25);
        public static final ParserMap_TransStartError TransStartError =
            new ParserMap_TransStartError("ParserMap.TransStartError", 26);
        public static final ParserMap_TransParams TransParams =
            new ParserMap_TransParams("ParserMap.TransParams", 27);
        public static final ParserMap_TransNext TransNext =
            new ParserMap_TransNext("ParserMap.TransNext", 28);
        public static final ParserMap_TransNextError TransNextError =
            new ParserMap_TransNextError("ParserMap.TransNextError", 29);
        public static final ParserMap_TransGuard TransGuard =
            new ParserMap_TransGuard("ParserMap.TransGuard", 30);
        public static final ParserMap_EndState EndState =
            new ParserMap_EndState("ParserMap.EndState", 31);
        public static final ParserMap_EndStateError EndStateError =
            new ParserMap_EndStateError("ParserMap.EndStateError", 32);
        public static final ParserMap_SimpleTrans SimpleTrans =
            new ParserMap_SimpleTrans("ParserMap.SimpleTrans", 33);
        public static final ParserMap_PushTransition PushTransition =
            new ParserMap_PushTransition("ParserMap.PushTransition", 34);
        public static final ParserMap_PushStart PushStart =
            new ParserMap_PushStart("ParserMap.PushStart", 35);
        public static final ParserMap_PushError PushError =
            new ParserMap_PushError("ParserMap.PushError", 36);
        public static final ParserMap_PushMap PushMap =
            new ParserMap_PushMap("ParserMap.PushMap", 37);
        public static final ParserMap_PushEnd PushEnd =
            new ParserMap_PushEnd("ParserMap.PushEnd", 38);
        public static final ParserMap_JumpStart JumpStart =
            new ParserMap_JumpStart("ParserMap.JumpStart", 39);
        public static final ParserMap_JumpError JumpError =
            new ParserMap_JumpError("ParserMap.JumpError", 40);
        public static final ParserMap_JumpMap JumpMap =
            new ParserMap_JumpMap("ParserMap.JumpMap", 41);
        public static final ParserMap_JumpEnd JumpEnd =
            new ParserMap_JumpEnd("ParserMap.JumpEnd", 42);
        public static final ParserMap_PopStart PopStart =
            new ParserMap_PopStart("ParserMap.PopStart", 43);
        public static final ParserMap_PopError PopError =
            new ParserMap_PopError("ParserMap.PopError", 44);
        public static final ParserMap_PopAction PopAction =
            new ParserMap_PopAction("ParserMap.PopAction", 45);
        public static final ParserMap_PopArgs PopArgs =
            new ParserMap_PopArgs("ParserMap.PopArgs", 46);
        public static final ParserMap_PopArgsEnd PopArgsEnd =
            new ParserMap_PopArgsEnd("ParserMap.PopArgsEnd", 47);
        public static final ParserMap_ActionStart ActionStart =
            new ParserMap_ActionStart("ParserMap.ActionStart", 48);
        public static final ParserMap_ActionEnd ActionEnd =
            new ParserMap_ActionEnd("ParserMap.ActionEnd", 49);
        public static final ParserMap_ActionStartError ActionStartError =
            new ParserMap_ActionStartError("ParserMap.ActionStartError", 50);
        @SuppressWarnings("unused")
        private static final ParserMap_Default Default =
            new ParserMap_Default("ParserMap.Default", -1);

    }

    @SuppressWarnings("serial")
    protected static class ParserMap_Default
        extends SmcParserState
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected ParserMap_Default(String name, int id)
        {
            super (name, id);
        }
    //-----------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_Start
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Start(String name, int id)
        {
            super (name, id);
        }

        protected void ACCESS(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : ACCESS(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Access);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void CLASS_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : CLASS_NAME(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Context);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void DECLARE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : DECLARE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Declare);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting \"%{ source %}\", %start, or %class.", ctxt.getLineNumber());
                ctxt.setHeaderLine(ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void FSM_CLASS_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : FSM_CLASS_NAME(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.FsmClassName);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void HEADER_FILE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : HEADER_FILE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.HeaderFile);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void IMPORT(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : IMPORT(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Import);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void INCLUDE_FILE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : INCLUDE_FILE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.IncludeFile);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : MAP_NAME(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Start [" + context.getName() + "]");
            }
            if (ctxt.isValidHeader() == true)
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.setHeaderLine(token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.MapName);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                    }
                }

            }
            else
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.error("%map not preceded by %start and %class.", token.getLineNumber());
                    ctxt.setHeaderLine(token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.StartError);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                    }
                }

            }

            return;
        }

        protected void PACKAGE_NAME(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : PACKAGE_NAME(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.Package);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SOURCE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Start [" + context.getName() + "]");
            }
            SmcParserState endState = context.getState();
            context.clearState();
            try
            {
                ctxt.setSource(token.getValue());
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(endState);
            }

            return;
        }

        protected void START_STATE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : START_STATE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartState);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_Context
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Context(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Context [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Context.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Context.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Missing name after %class.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Context.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Context.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Context [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Context.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Context.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setContext(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Context.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Context.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_StartState
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_StartState(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StartState [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StartState.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StartState.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Missing state after %start.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StartState.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.StartState.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StartState [" + context.getName() + "]");
            }
            if (ctxt.isValidStartState(token.getValue()) == true)
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StartState.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StartState.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.setStartState(token.getValue());
                }
                finally
                {
                    context.setState(ParserMap.Start);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StartState.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParserMap.ParserMap.StartState.Entry(context) [" + context.getName() + "]");
                    }
                }

            }
            else
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StartState.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StartState.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.error("Start state must be of the form \"map::state\".", token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.StartError);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StartState.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParserMap.ParserMap.StartState.Entry(context) [" + context.getName() + "]");
                    }
                }

            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_HeaderFile
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_HeaderFile(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("\n\r\f");
            return;
        }

        protected void Exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.HeaderFile [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.HeaderFile.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.HeaderFile.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Missing header file after %header.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.HeaderFile.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.HeaderFile.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SOURCE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.HeaderFile [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.HeaderFile.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.HeaderFile.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeader(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.HeaderFile.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.HeaderFile.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_IncludeFile
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_IncludeFile(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("\n\r\f");
            return;
        }

        protected void Exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.IncludeFile [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.IncludeFile.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.IncludeFile.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Missing include file after %include.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.IncludeFile.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.IncludeFile.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SOURCE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.IncludeFile [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.IncludeFile.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.IncludeFile.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.addInclude(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.IncludeFile.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.IncludeFile.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_Package
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Package(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Package [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Package.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Package.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Missing name after %package.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Package.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Package.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Package [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Package.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Package.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setPackageName(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Package.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Package.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_FsmClassName
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_FsmClassName(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.FsmClassName [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.FsmClassName.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.FsmClassName.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Missing name after %FsmClassName.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.FsmClassName.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.FsmClassName.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.FsmClassName [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.FsmClassName.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.FsmClassName.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setFsmClassName(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.FsmClassName.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.FsmClassName.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_Import
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Import(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("\n\r\f");
            return;
        }

        protected void Exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Import [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Import.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Import.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Missing name after %import.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Import.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Import.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SOURCE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Import [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Import.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Import.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.addImport(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Import.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Import.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_Declare
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Declare(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("\n\r\f");
            return;
        }

        protected void Exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Declare [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Declare.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Declare.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Missing name after %declare.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Declare.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Declare.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SOURCE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Declare [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Declare.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Declare.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.addDeclare(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Declare.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Declare.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_Access
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Access(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("\n\r\f");
            return;
        }

        protected void Exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Access [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Access.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Access.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Missing access level after %access.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Access.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Access.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SOURCE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Access [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Access.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Access.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setAccessLevel(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Access.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Access.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_StartError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_StartError(String name, int id)
        {
            super (name, id);
        }

        protected void ACCESS(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : ACCESS(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.Access);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void CLASS_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : CLASS_NAME(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Context);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void DECLARE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : DECLARE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Declare);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void Default(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StartError [" + context.getName() + "]");
            }
            return;
        }

        protected void FSM_CLASS_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : FSM_CLASS_NAME(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.FsmClassName);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void HEADER_FILE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : HEADER_FILE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.HeaderFile);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void IMPORT(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : IMPORT(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Import);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : MAP_NAME(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StartError [" + context.getName() + "]");
            }
            if (ctxt.isValidHeader() == true)
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.setHeaderLine(token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.MapName);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                    }
                }

            }
            else
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.error("%map not preceded by %start and %class.", token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.StartError);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                    }
                }

            }

            return;
        }

        protected void PACKAGE_NAME(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : PACKAGE_NAME(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.Package);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void START_STATE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : START_STATE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StartError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartState);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.StartError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_MapStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_MapStart(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.MapStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.MapStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting %map.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.MapStartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.MapStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.MapStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : MAP_NAME(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.MapStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.MapStart.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.MapName);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.MapStart.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.MapStart.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_MapStartError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_MapStartError(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapStartError [" + context.getName() + "]");
            }
            return;
        }

        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : MAP_NAME(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapStartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.MapStartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.MapStartError.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.MapName);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.MapStartError.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.MapStartError.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_MapName
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_MapName(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapName [" + context.getName() + "]");
            }
            SmcParserState endState = context.getState();
            context.clearState();
            try
            {
                ctxt.error("Name expected after \"%map\".", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(endState);
            }

            return;
        }

        protected void EOD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : EOD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapName [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.MapName.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.MapName.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Name expected after \"%map\".", token.getLineNumber());
                ctxt.createMap(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.States);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.MapName.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.MapName.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapName [" + context.getName() + "]");
            }
            if (ctxt.isDuplicateMap(token.getValue()) == true)
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.MapName.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.MapName.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.error("Duplicate map name.", token.getLineNumber());
                    ctxt.createMap(token.getValue(), token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.MapStates);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParserMap.ParserMap.MapName.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParserMap.ParserMap.MapName.Entry(context) [" + context.getName() + "]");
                    }
                }

            }
            else
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.MapName.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.MapName.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.createMap(token.getValue(), token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.MapStates);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParserMap.ParserMap.MapName.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParserMap.ParserMap.MapName.Entry(context) [" + context.getName() + "]");
                    }
                }

            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_MapStates
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_MapStates(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapStates [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.MapStates.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.MapStates.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting %% after \"%map mapname\".", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.MapStatesError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.MapStates.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.MapStates.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void EOD(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : EOD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapStates [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.MapStates.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.MapStates.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.States);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.MapStates.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.MapStates.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapStates [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.MapStates.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.MapStates.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting %% after \"%map mapname\".", token.getLineNumber());
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StateStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.MapStates.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.MapStates.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_MapStatesError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_MapStatesError(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapStatesError [" + context.getName() + "]");
            }
            return;
        }

        protected void EOD(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : EOD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapStatesError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.MapStatesError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.MapStatesError.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.States);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.MapStatesError.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.MapStatesError.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : MAP_NAME(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapStatesError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.MapStatesError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.MapStatesError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.addMap();
            }
            finally
            {
                context.setState(ParserMap.MapName);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.MapStatesError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.MapStatesError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.MapStatesError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.MapStatesError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.MapStatesError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StateStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.MapStatesError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.MapStatesError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_States
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_States(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.States [" + context.getName() + "]");
            }
            SmcParserState endState = context.getState();
            context.clearState();
            try
            {
                ctxt.error("Expecting either a new state definition or end of map (%%).", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(endState);
            }

            return;
        }

        protected void ENTRY(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : ENTRY(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.States [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.EntryStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void EOD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : EOD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.States [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.addMap();
            }
            finally
            {
                context.setState(ParserMap.MapStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void EQUAL(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : EQUAL(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.States [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Transitions);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void EXIT(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : EXIT(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.States [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.ExitStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.States [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Transitions);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : MAP_NAME(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.States [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting \"%%\" before another \"%map\".", token.getLineNumber());
                ctxt.addMap();
            }
            finally
            {
                context.setState(ParserMap.MapName);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.States [" + context.getName() + "]");
            }
            if (ctxt.isDuplicateState(token.getValue()) == true)
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.error("Duplicate state name.", token.getLineNumber());
                    ctxt.createState(token.getValue(), token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.StateStart);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                    }
                }

            }
            else
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.States.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.createState(token.getValue(), token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.StateStart);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParserMap.ParserMap.States.Entry(context) [" + context.getName() + "]");
                    }
                }

            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_StateStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_StateStart(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StateStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StateStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StateStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("After the state name is given, then either an entry action, exit action or opening brace is expected.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StateStartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StateStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.StateStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void ENTRY(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : ENTRY(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StateStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StateStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StateStart.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.EntryStart);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StateStart.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.StateStart.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void EXIT(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : EXIT(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StateStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StateStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StateStart.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.ExitStart);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StateStart.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.StateStart.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StateStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StateStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StateStart.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.Transitions);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StateStart.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.StateStart.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_StateStartError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_StateStartError(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StateStartError [" + context.getName() + "]");
            }
            return;
        }

        protected void ENTRY(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : ENTRY(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StateStartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StateStartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StateStartError.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.EntryStart);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StateStartError.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.StateStartError.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void EXIT(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : EXIT(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StateStartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StateStartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StateStartError.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.ExitStart);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StateStartError.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.StateStartError.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.StateStartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.StateStartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.StateStartError.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.Transitions);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.StateStartError.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.StateStartError.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_EntryStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_EntryStart(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.EntryStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.EntryStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.EntryStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("An opening brace is expected after Entry.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StateStartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.EntryStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.EntryStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.EntryStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.EntryStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.EntryStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.EntryEnd);
                (context.getState()).Entry(context);
                context.pushState(ActionMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.EntryStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.EntryStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_EntryEnd
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_EntryEnd(String name, int id)
        {
            super (name, id);
        }

        protected void actionsDone(SmcParserContext context, List<SmcAction> actions, int lineNumber)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : actionsDone(actions: List<SmcAction>, lineNumber: int) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.EntryEnd [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.EntryEnd.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.EntryEnd.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setEntryAction(actions);
            }
            finally
            {
                context.setState(ParserMap.StateStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.EntryEnd.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.EntryEnd.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void actionsError(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : actionsError() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.EntryEnd [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.EntryEnd.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.EntryEnd.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.StartState);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.EntryEnd.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.EntryEnd.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_ExitStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_ExitStart(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.ExitStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.ExitStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.ExitStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("A opening brace is expected after Exit.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StateStartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.ExitStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.ExitStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.ExitStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.ExitStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.ExitStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ExitEnd);
                (context.getState()).Entry(context);
                context.pushState(ActionMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.ExitStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.ExitStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_ExitEnd
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_ExitEnd(String name, int id)
        {
            super (name, id);
        }

        protected void actionsDone(SmcParserContext context, List<SmcAction> actions, int lineNumber)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : actionsDone(actions: List<SmcAction>, lineNumber: int) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.ExitEnd [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.ExitEnd.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.ExitEnd.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setExitAction(actions);
            }
            finally
            {
                context.setState(ParserMap.StateStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.ExitEnd.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.ExitEnd.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void actionsError(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : actionsError() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.ExitEnd [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.ExitEnd.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.ExitEnd.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.StateStart);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.ExitEnd.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.ExitEnd.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_Transitions
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Transitions(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Transitions [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Transitions.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Transitions.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting either a new transition or a closing brace.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.TransError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Transitions.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Transitions.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Transitions [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Transitions.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Transitions.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.addState();
            }
            finally
            {
                context.setState(ParserMap.States);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Transitions.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Transitions.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.Transitions [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.Transitions.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.Transitions.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.storeTransitionName(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.TransStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.Transitions.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.Transitions.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_TransError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransError(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransError [" + context.getName() + "]");
            }
            return;
        }

        protected void RIGHT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.addState();
            }
            finally
            {
                context.setState(ParserMap.States);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.storeTransitionName(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.TransStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_TransStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransStart(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting either a guard, \"push\", \"pop\", \"jump\" or end state.", ctxt.getLineNumber());
                ctxt.createTransition(ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.TransStartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void JUMP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : JUMP(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createTransition(token.getLineNumber());
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
            }
            finally
            {
                context.setState(ParserMap.JumpStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_BRACKET(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACKET(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createTransition(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.TransGuard);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.TransParams);
            (context.getState()).Entry(context);
            context.pushState(ParamMap.Start);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void POP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : POP(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createTransition(token.getLineNumber());
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_POP);
            }
            finally
            {
                context.setState(ParserMap.PopStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : PUSH(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createTransition(token.getLineNumber());
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_PUSH);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.PushStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createTransition(token.getLineNumber());
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.SimpleTrans);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_TransStartError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransStartError(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStartError [" + context.getName() + "]");
            }
            return;
        }

        protected void JUMP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : JUMP(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.JumpStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState("End state missing");
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).Entry(context);
                context.pushState(ActionMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_BRACKET(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACKET(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.TransGuard);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.TransParams);
            (context.getState()).Entry(context);
            context.pushState(ParamMap.Start);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void POP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : POP(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_POP);
            }
            finally
            {
                context.setState(ParserMap.PopStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : PUSH(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_PUSH);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.PushStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransStartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransStartError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.addGuard();
                ctxt.addTransition();
            }
            finally
            {
                context.setState(ParserMap.Transitions);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransStartError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_TransParams
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransParams(String name, int id)
        {
            super (name, id);
        }

        protected void paramsDone(SmcParserContext context, List<SmcParameter> params, int lineNumber)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : paramsDone(params: List<SmcParameter>, lineNumber: int) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransParams [" + context.getName() + "]");
            }
            if (ctxt.getTransitionName().equalsIgnoreCase(
           "Default") == true &&
       params.isEmpty() == false)
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransParams.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransParams.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.error("Default transitions may not have parameters.", lineNumber);
                    ctxt.createTransition(params, lineNumber);
                }
                finally
                {
                    context.setState(ParserMap.TransNext);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransParams.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransParams.Entry(context) [" + context.getName() + "]");
                    }
                }

            }
            else
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransParams.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransParams.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.createTransition(params, lineNumber);
                }
                finally
                {
                    context.setState(ParserMap.TransNext);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransParams.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransParams.Entry(context) [" + context.getName() + "]");
                    }
                }

            }

            return;
        }

        protected void paramsError(SmcParserContext context, List<SmcParameter> params, int lineNumber)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : paramsError(params: List<SmcParameter>, lineNumber: int) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransParams [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransParams.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransParams.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createTransition(params, lineNumber);
            }
            finally
            {
                context.setState(ParserMap.TransNext);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransParams.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransParams.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_TransNext
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransNext(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransNext [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransNext.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransNext.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting either a guard, \"push\", \"pop\", \"jump\" or end state.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.TransNextError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransNext.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransNext.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void JUMP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : JUMP(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransNext [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransNext.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransNext.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.JumpStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransNext.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransNext.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_BRACKET(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACKET(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransNext [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransNext.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransNext.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.TransGuard);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransNext.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransNext.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void POP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : POP(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransNext [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransNext.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransNext.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_POP);
            }
            finally
            {
                context.setState(ParserMap.PopStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransNext.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransNext.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : PUSH(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransNext [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransNext.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransNext.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_PUSH);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.PushStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransNext.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransNext.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransNext [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransNext.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransNext.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.SimpleTrans);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransNext.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransNext.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_TransNextError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransNextError(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransNextError [" + context.getName() + "]");
            }
            return;
        }

        protected void JUMP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : JUMP(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransNextError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransNextError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransNextError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.JumpStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransNextError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransNextError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_BRACKET(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACKET(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransNextError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransNextError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransNextError.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.TransGuard);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransNextError.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransNextError.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransNextError [" + context.getName() + "]");
            }
            return;
        }

        protected void POP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : POP(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransNextError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransNextError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransNextError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_POP);
            }
            finally
            {
                context.setState(ParserMap.PopStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransNextError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransNextError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : PUSH(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransNextError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransNextError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransNextError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_PUSH);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.PushStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransNextError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransNextError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransNextError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransNextError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransNextError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.SimpleTrans);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransNextError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransNextError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_TransGuard
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransGuard(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("[", "]");
            return;
        }

        protected void Exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SOURCE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.TransGuard [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.TransGuard.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.TransGuard.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.EndState);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.TransGuard.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.TransGuard.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_EndState
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_EndState(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.EndState [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.EndState.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.EndState.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting either \"push\", \"pop\", \"jump\" or end state.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.EndStateError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.EndState.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.EndState.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void JUMP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : JUMP(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.EndState [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.EndState.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.EndState.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.JumpStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.EndState.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.EndState.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void POP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : POP(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.EndState [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.EndState.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.EndState.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setTransType(TransType.TRANS_POP);
            }
            finally
            {
                context.setState(ParserMap.PopStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.EndState.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.EndState.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : PUSH(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.EndState [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.EndState.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.EndState.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setTransType(TransType.TRANS_PUSH);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.PushStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.EndState.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.EndState.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.EndState [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.EndState.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.EndState.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.SimpleTrans);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.EndState.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.EndState.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_EndStateError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_EndStateError(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.EndStateError [" + context.getName() + "]");
            }
            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.EndStateError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.EndStateError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.EndStateError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).Entry(context);
                context.pushState(ActionMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.EndStateError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.EndStateError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_SimpleTrans
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_SimpleTrans(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.SimpleTrans [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.SimpleTrans.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.SimpleTrans.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("An opening brace must proceed any action definitions.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.ActionStartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.SimpleTrans.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.SimpleTrans.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.SimpleTrans [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.SimpleTrans.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.SimpleTrans.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).Entry(context);
                context.pushState(ActionMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.SimpleTrans.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.SimpleTrans.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void SLASH(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SLASH(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.SimpleTrans [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.SimpleTrans.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.SimpleTrans.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setTransType(TransType.TRANS_PUSH);
            }
            finally
            {
                context.setState(ParserMap.PushTransition);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.SimpleTrans.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.SimpleTrans.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_PushTransition
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PushTransition(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PushTransition [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PushTransition.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PushTransition.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("\"push\" must follow a '/'.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PushError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PushTransition.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.PushTransition.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : PUSH(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PushTransition [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PushTransition.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PushTransition.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.PushStart);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PushTransition.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.PushTransition.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_PushStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PushStart(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PushStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PushStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PushStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("\"push\" must be followed by a '/'.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PushError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PushStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.PushStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PushStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PushStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PushStart.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.PushMap);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PushStart.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.PushStart.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_PushError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PushError(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PushError [" + context.getName() + "]");
            }
            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PushError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PushError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PushError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).Entry(context);
                context.pushState(ActionMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PushError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.PushError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PushError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PushError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PushError.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.ActionStart);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PushError.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.PushError.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_PushMap
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PushMap(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PushMap [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PushMap.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PushMap.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting a state name.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PushError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PushMap.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.PushMap.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PushMap [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PushMap.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PushMap.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setPushState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.PushEnd);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PushMap.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.PushMap.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_PushEnd
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PushEnd(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PushEnd [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PushEnd.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PushEnd.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("push transition missing closing paren.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PushError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PushEnd.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.PushEnd.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PushEnd [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PushEnd.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PushEnd.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.ActionStart);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PushEnd.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.PushEnd.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_JumpStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_JumpStart(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.JumpStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.JumpStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.JumpStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("\"jump\" must be followed by a '/'.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.JumpError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.JumpStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.JumpStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.JumpStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.JumpStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.JumpStart.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.JumpMap);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.JumpStart.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.JumpStart.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_JumpError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_JumpError(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.JumpError [" + context.getName() + "]");
            }
            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.JumpError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.JumpError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.JumpError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).Entry(context);
                context.pushState(ActionMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.JumpError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.JumpError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.JumpError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.JumpError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.JumpError.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.ActionStart);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.JumpError.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.JumpError.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_JumpMap
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_JumpMap(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.JumpMap [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.JumpMap.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.JumpMap.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting a state name.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.JumpError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.JumpMap.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.JumpMap.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.JumpMap [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.JumpMap.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.JumpMap.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setEndState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.JumpEnd);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.JumpMap.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.JumpMap.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_JumpEnd
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_JumpEnd(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.JumpEnd [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.JumpEnd.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.JumpEnd.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("jump transition missing closing paren.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.JumpError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.JumpEnd.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.JumpEnd.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.JumpEnd [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.JumpEnd.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.JumpEnd.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.ActionStart);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.JumpEnd.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.JumpEnd.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_PopStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PopStart(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PopStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PopStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PopStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting '(trans)' or opening brace after pop.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PopError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PopStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.PopStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PopStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PopStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PopStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).Entry(context);
                context.pushState(ActionMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PopStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.PopStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PopStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PopStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PopStart.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.PopAction);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PopStart.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.PopStart.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_PopError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PopError(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PopError [" + context.getName() + "]");
            }
            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PopError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PopError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PopError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).Entry(context);
                context.pushState(ActionMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PopError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.PopError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PopError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PopError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PopError.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.ActionStart);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PopError.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.PopError.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_PopAction
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PopAction(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PopAction [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PopAction.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PopAction.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting either a pop transition or closing paren.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PopError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PopAction.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.PopAction.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PopAction [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PopAction.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PopAction.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.ActionStart);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PopAction.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.PopAction.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PopAction [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PopAction.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PopAction.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setEndState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.PopArgs);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PopAction.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.PopAction.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_PopArgs
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PopArgs(String name, int id)
        {
            super (name, id);
        }

        protected void COMMA(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : COMMA(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PopArgs [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PopArgs.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PopArgs.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.PopArgsEnd);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PopArgs.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.PopArgs.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PopArgs [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PopArgs.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PopArgs.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Pop transition missing closing paren.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PopError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PopArgs.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.PopArgs.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PopArgs [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PopArgs.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PopArgs.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.ActionStart);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PopArgs.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.PopArgs.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_PopArgsEnd
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PopArgsEnd(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("(", ")");
            return;
        }

        protected void Exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SOURCE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.PopArgsEnd [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.PopArgsEnd.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.PopArgsEnd.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setPopArgs(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.ActionStart);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.PopArgsEnd.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.PopArgsEnd.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_ActionStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_ActionStart(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.ActionStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.ActionStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.ActionStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("An opening brace must proceed any action definitions.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.ActionStartError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.ActionStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.ActionStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.ActionStart [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.ActionStart.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.ActionStart.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).Entry(context);
                context.pushState(ActionMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.ActionStart.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.ActionStart.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_ActionEnd
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_ActionEnd(String name, int id)
        {
            super (name, id);
        }

        protected void actionsDone(SmcParserContext context, List<SmcAction> actions, int lineNumber)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : actionsDone(actions: List<SmcAction>, lineNumber: int) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.ActionEnd [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.ActionEnd.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.ActionEnd.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setActions(actions);
                ctxt.addGuard();
                ctxt.addTransition();
            }
            finally
            {
                context.setState(ParserMap.Transitions);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.ActionEnd.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.ActionEnd.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void actionsError(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : actionsError() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.ActionEnd [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.ActionEnd.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.ActionEnd.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParserMap.Transitions);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParserMap.ParserMap.ActionEnd.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParserMap.ParserMap.ActionEnd.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParserMap_ActionStartError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_ActionStartError(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.ActionStartError [" + context.getName() + "]");
            }
            return;
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParserMap.ActionStartError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParserMap.ParserMap.ActionStartError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParserMap.ParserMap.ActionStartError.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).Entry(context);
                context.pushState(ActionMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParserMap.ParserMap.ActionStartError.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParserMap.ParserMap.ActionStartError.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    public static abstract class ParamMap
    {
    //-----------------------------------------------------------
    // Member methods.
    //

    //-----------------------------------------------------------
    // Member data.
    //

        //-------------------------------------------------------
        // Constants.
        //
        public static final ParamMap_Start Start =
            new ParamMap_Start("ParamMap.Start", 0);
        public static final ParamMap_Dollar Dollar =
            new ParamMap_Dollar("ParamMap.Dollar", 1);
        public static final ParamMap_ParamSeparator ParamSeparator =
            new ParamMap_ParamSeparator("ParamMap.ParamSeparator", 2);
        public static final ParamMap_ParamType ParamType =
            new ParamMap_ParamType("ParamMap.ParamType", 3);
        public static final ParamMap_NextParam NextParam =
            new ParamMap_NextParam("ParamMap.NextParam", 4);
        public static final ParamMap_Error Error =
            new ParamMap_Error("ParamMap.Error", 5);
        @SuppressWarnings("unused")
        private static final ParamMap_Default Default =
            new ParamMap_Default("ParamMap.Default", -1);

    }

    @SuppressWarnings("serial")
    protected static class ParamMap_Default
        extends SmcParserState
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected ParamMap_Default(String name, int id)
        {
            super (name, id);
        }
    //-----------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParamMap_Start
        extends ParamMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParamMap_Start(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.createParamList();
            return;
        }

        protected void DOLLAR(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : DOLLAR(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.Start [" + context.getName() + "]");
            }
            if (ctxt.getTargetLanguage() == TargetLanguage.PERL ||
       ctxt.getTargetLanguage() == TargetLanguage.PHP ||
       ctxt.getTargetLanguage() == TargetLanguage.GRAPH ||
       ctxt.getTargetLanguage() == TargetLanguage.TABLE)
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.Start.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.Start.Exit(context) [" + context.getName() + "]");
                    }

                // No actions.
                context.setState(ParamMap.Dollar);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParamMap.ParamMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParamMap.ParamMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }
            else
            {
                super.DOLLAR(context, token);
            }

            return;
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParamMap.Error);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParamMap.ParamMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParamMap.ParamMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.popState();

            context.paramsDone(
            ctxt.getParamList(),
            token.getLineNumber());
            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createParameter(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParamMap.ParamSeparator);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParamMap.ParamMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParamMap.ParamMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParamMap_Dollar
        extends ParamMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParamMap_Dollar(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.Dollar [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.Dollar.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.Dollar.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParamMap.Error);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParamMap.ParamMap.Dollar.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParamMap.ParamMap.Dollar.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.Dollar [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.Dollar.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.Dollar.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createParameter("$" + token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParamMap.ParamSeparator);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParamMap.ParamMap.Dollar.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParamMap.ParamMap.Dollar.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParamMap_ParamSeparator
        extends ParamMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParamMap_ParamSeparator(String name, int id)
        {
            super (name, id);
        }

        protected void COLON(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : COLON(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.ParamSeparator [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.ParamSeparator.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.ParamSeparator.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ParamMap.ParamType);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ParamMap.ParamMap.ParamSeparator.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ParamMap.ParamMap.ParamSeparator.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

        protected void COMMA(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : COMMA(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.ParamSeparator [" + context.getName() + "]");
            }
            if (ctxt.getTargetLanguage() == TargetLanguage.TCL ||
       ctxt.getTargetLanguage() == TargetLanguage.GROOVY ||
       ctxt.getTargetLanguage() == TargetLanguage.LUA ||
       ctxt.getTargetLanguage() == TargetLanguage.PERL ||
       ctxt.getTargetLanguage() == TargetLanguage.PHP ||
       ctxt.getTargetLanguage() == TargetLanguage.PYTHON ||
       ctxt.getTargetLanguage() == TargetLanguage.RUBY ||
       ctxt.getTargetLanguage() == TargetLanguage.GRAPH ||
       ctxt.getTargetLanguage() == TargetLanguage.TABLE)
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.ParamSeparator.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.ParamSeparator.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.addParameter();
                }
                finally
                {
                    context.setState(ParamMap.Start);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParamMap.ParamMap.ParamSeparator.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParamMap.ParamMap.ParamSeparator.Entry(context) [" + context.getName() + "]");
                    }
                }

            }
            else
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.ParamSeparator.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.ParamSeparator.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.error("Parameter type missing.", token.getLineNumber());
                }
                finally
                {
                    context.setState(ParamMap.Error);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ParamMap.ParamMap.ParamSeparator.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ParamMap.ParamMap.ParamSeparator.Entry(context) [" + context.getName() + "]");
                    }
                }

            }

            return;
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.ParamSeparator [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.ParamSeparator.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.ParamSeparator.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParamMap.Error);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParamMap.ParamMap.ParamSeparator.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParamMap.ParamMap.ParamSeparator.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.ParamSeparator [" + context.getName() + "]");
            }
            if (ctxt.getTargetLanguage() == TargetLanguage.TCL ||
       ctxt.getTargetLanguage() == TargetLanguage.GROOVY ||
       ctxt.getTargetLanguage() == TargetLanguage.LUA ||
       ctxt.getTargetLanguage() == TargetLanguage.PERL ||
       ctxt.getTargetLanguage() == TargetLanguage.PHP ||
       ctxt.getTargetLanguage() == TargetLanguage.PYTHON ||
       ctxt.getTargetLanguage() == TargetLanguage.RUBY ||
       ctxt.getTargetLanguage() == TargetLanguage.GRAPH ||
       ctxt.getTargetLanguage() == TargetLanguage.TABLE)
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.ParamSeparator.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.ParamSeparator.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.addParameter();
                }
                finally
                {
                    context.popState();
                }


                context.paramsDone(
            ctxt.getParamList(),
            token.getLineNumber());
            }
            else
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.ParamSeparator.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.ParamSeparator.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.error("Parameter type missing.", token.getLineNumber());
                }
                finally
                {
                    context.popState();
                }


                context.paramsError(
            ctxt.getParamList(),
            token.getLineNumber());
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParamMap_ParamType
        extends ParamMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParamMap_ParamType(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode2();
            return;
        }

        protected void Exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SOURCE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.ParamType [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.ParamType.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.ParamType.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setParamType(token.getValue());
            }
            finally
            {
                context.setState(ParamMap.NextParam);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParamMap.ParamMap.ParamType.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParamMap.ParamMap.ParamType.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParamMap_NextParam
        extends ParamMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParamMap_NextParam(String name, int id)
        {
            super (name, id);
        }

        protected void COMMA(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : COMMA(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.NextParam [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.NextParam.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.NextParam.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.addParameter();
            }
            finally
            {
                context.setState(ParamMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParamMap.ParamMap.NextParam.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParamMap.ParamMap.NextParam.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.NextParam [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.NextParam.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.NextParam.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParamMap.Error);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ParamMap.ParamMap.NextParam.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ParamMap.ParamMap.NextParam.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.NextParam [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.NextParam.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.NextParam.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.addParameter();
            }
            finally
            {
                context.popState();
            }


            context.paramsDone(
            ctxt.getParamList(),
            token.getLineNumber());
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ParamMap_Error
        extends ParamMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParamMap_Error(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("(", ")");
            ctxt.clearParameter();
            return;
        }

        protected void Exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SOURCE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ParamMap.Error [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ParamMap.ParamMap.Error.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ParamMap.ParamMap.Error.Exit(context) [" + context.getName() + "]");
                }

            context.popState();

            context.paramsError(
            ctxt.getParamList(),
            token.getLineNumber());
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    public static abstract class ActionMap
    {
    //-----------------------------------------------------------
    // Member methods.
    //

    //-----------------------------------------------------------
    // Member data.
    //

        //-------------------------------------------------------
        // Constants.
        //
        public static final ActionMap_Start Start =
            new ActionMap_Start("ActionMap.Start", 0);
        public static final ActionMap_ActionName ActionName =
            new ActionMap_ActionName("ActionMap.ActionName", 1);
        public static final ActionMap_ActionArgs ActionArgs =
            new ActionMap_ActionArgs("ActionMap.ActionArgs", 2);
        public static final ActionMap_ActionEnd ActionEnd =
            new ActionMap_ActionEnd("ActionMap.ActionEnd", 3);
        public static final ActionMap_PropertyAssignment PropertyAssignment =
            new ActionMap_PropertyAssignment("ActionMap.PropertyAssignment", 4);
        public static final ActionMap_ActionError ActionError =
            new ActionMap_ActionError("ActionMap.ActionError", 5);
        @SuppressWarnings("unused")
        private static final ActionMap_Default Default =
            new ActionMap_Default("ActionMap.Default", -1);

    }

    @SuppressWarnings("serial")
    protected static class ActionMap_Default
        extends SmcParserState
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected ActionMap_Default(String name, int id)
        {
            super (name, id);
        }
    //-----------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ActionMap_Start
        extends ActionMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ActionMap_Start(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.clearActions();
                ctxt.error("Expecting either a method name or a closing brace", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ActionMap.ActionError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ActionMap.ActionMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ActionMap.ActionMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.popState();

            context.actionsDone(
            ctxt.getActionList(),
            token.getLineNumber());
            return;
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : WORD(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createAction(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ActionMap.ActionName);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ActionMap.ActionMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ActionMap.ActionMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ActionMap_ActionName
        extends ActionMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ActionMap_ActionName(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.ActionName [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.ActionName.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.ActionName.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.clearActions();
                ctxt.error("Expecting an open paren after the method name", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ActionMap.ActionError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ActionMap.ActionMap.ActionName.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ActionMap.ActionMap.ActionName.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void EQUAL(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : EQUAL(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.ActionName [" + context.getName() + "]");
            }
            if (ctxt.getTargetLanguage() != TargetLanguage.GRAPH &&
       ctxt.getTargetLanguage() != TargetLanguage.C_SHARP &&
       ctxt.getTargetLanguage() != TargetLanguage.GROOVY &&
       ctxt.getTargetLanguage() != TargetLanguage.LUA &&
       ctxt.getTargetLanguage() != TargetLanguage.PERL &&
       ctxt.getTargetLanguage() != TargetLanguage.PYTHON &&
       ctxt.getTargetLanguage() != TargetLanguage.RUBY &&
       ctxt.getTargetLanguage() != TargetLanguage.SCALA &&
       ctxt.getTargetLanguage() != TargetLanguage.VB &&
       ctxt.getTargetLanguage() != TargetLanguage.TABLE)
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.ActionName.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.ActionName.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.clearActions();
                    ctxt.error("'=' property assignment may only be used with -vb, -csharp or -graph", token.getLineNumber());
                }
                finally
                {
                    context.setState(ActionMap.ActionError);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ActionMap.ActionMap.ActionName.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ActionMap.ActionMap.ActionName.Entry(context) [" + context.getName() + "]");
                    }
                }

            }
            else
            {
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.ActionName.Exit(context) [" + context.getName() + "]");
                }

                (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.ActionName.Exit(context) [" + context.getName() + "]");
                    }

                context.clearState();
                try
                {
                    ctxt.setProperty(true);
                    ctxt.createArgList();
                }
                finally
                {
                    context.setState(ActionMap.PropertyAssignment);

                    if (log.isTraceEnabled())
                    {
                        log.trace("BEFORE ENTRY    : ActionMap.ActionMap.ActionName.Entry(context) [" + context.getName() + "]");
                    }

                    (context.getState()).Entry(context);

                    if (log.isTraceEnabled())
                    {
                        log.trace("AFTER ENTRY     : ActionMap.ActionMap.ActionName.Entry(context) [" + context.getName() + "]");
                    }
                }

            }

            return;
        }

        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : LEFT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.ActionName [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.ActionName.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.ActionName.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createArgList();
            }
            finally
            {
                context.setState(ActionMap.ActionArgs);
                (context.getState()).Entry(context);
                context.pushState(ArgsMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ActionMap.ActionMap.ActionName.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ActionMap.ActionMap.ActionName.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ActionMap_ActionArgs
        extends ActionMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ActionMap_ActionArgs(String name, int id)
        {
            super (name, id);
        }

        protected void argsDone(SmcParserContext context, List<String> args)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : argsDone(args: List<String>) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.ActionArgs [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.ActionArgs.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.ActionArgs.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.setActionArgs(args);
            }
            finally
            {
                context.setState(ActionMap.ActionEnd);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ActionMap.ActionMap.ActionArgs.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ActionMap.ActionMap.ActionArgs.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void argsError(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : argsError() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.ActionArgs [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.ActionArgs.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.ActionArgs.Exit(context) [" + context.getName() + "]");
                }

            context.setState(ActionMap.ActionError);

            if (log.isTraceEnabled())
            {
                log.trace("BEFORE ENTRY    : ActionMap.ActionMap.ActionArgs.Entry(context) [" + context.getName() + "]");
            }

            (context.getState()).Entry(context);

            if (log.isTraceEnabled())
            {
                log.trace("AFTER ENTRY     : ActionMap.ActionMap.ActionArgs.Entry(context) [" + context.getName() + "]");
            }
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ActionMap_ActionEnd
        extends ActionMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ActionMap_ActionEnd(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.ActionEnd [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.ActionEnd.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.ActionEnd.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Expecting a ';' after closing paren", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ActionMap.ActionError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ActionMap.ActionMap.ActionEnd.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ActionMap.ActionMap.ActionEnd.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void SEMICOLON(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SEMICOLON(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.ActionEnd [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.ActionEnd.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.ActionEnd.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.addAction();
            }
            finally
            {
                context.setState(ActionMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ActionMap.ActionMap.ActionEnd.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ActionMap.ActionMap.ActionEnd.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ActionMap_PropertyAssignment
        extends ActionMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ActionMap_PropertyAssignment(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode(";");
            return;
        }

        protected void Exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.PropertyAssignment [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.PropertyAssignment.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.PropertyAssignment.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Missing ';' at end of property assignment", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ActionMap.ActionError);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ActionMap.ActionMap.PropertyAssignment.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ActionMap.ActionMap.PropertyAssignment.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SOURCE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.PropertyAssignment [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.PropertyAssignment.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.PropertyAssignment.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createArgument(token.getValue(), token.getLineNumber());
                ctxt.addArgument();
                ctxt.setActionArgs(ctxt.getArgsList());
                ctxt.addAction();
            }
            finally
            {
                context.setState(ActionMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ActionMap.ActionMap.PropertyAssignment.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ActionMap.ActionMap.PropertyAssignment.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ActionMap_ActionError
        extends ActionMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ActionMap_ActionError(String name, int id)
        {
            super (name, id);
        }

        protected void Default(SmcParserContext context)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.ActionError [" + context.getName() + "]");
            }
            return;
        }

        protected void RIGHT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_BRACE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ActionMap.ActionError [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ActionMap.ActionMap.ActionError.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ActionMap.ActionMap.ActionError.Exit(context) [" + context.getName() + "]");
                }

            context.popState();

            context.actionsError();
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    public static abstract class ArgsMap
    {
    //-----------------------------------------------------------
    // Member methods.
    //

    //-----------------------------------------------------------
    // Member data.
    //

        //-------------------------------------------------------
        // Constants.
        //
        public static final ArgsMap_Start Start =
            new ArgsMap_Start("ArgsMap.Start", 0);
        public static final ArgsMap_NextArg NextArg =
            new ArgsMap_NextArg("ArgsMap.NextArg", 1);
        public static final ArgsMap_Error Error =
            new ArgsMap_Error("ArgsMap.Error", 2);
        @SuppressWarnings("unused")
        private static final ArgsMap_Default Default =
            new ArgsMap_Default("ArgsMap.Default", -1);

    }

    @SuppressWarnings("serial")
    protected static class ArgsMap_Default
        extends SmcParserState
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected ArgsMap_Default(String name, int id)
        {
            super (name, id);
        }
    //-----------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ArgsMap_Start
        extends ArgsMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ArgsMap_Start(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode2();
            return;
        }

        protected void Exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SOURCE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ArgsMap.Start [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ArgsMap.ArgsMap.Start.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ArgsMap.ArgsMap.Start.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.createArgument(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ArgsMap.NextArg);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ArgsMap.ArgsMap.Start.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ArgsMap.ArgsMap.Start.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ArgsMap_NextArg
        extends ArgsMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ArgsMap_NextArg(String name, int id)
        {
            super (name, id);
        }

        protected void COMMA(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : COMMA(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ArgsMap.NextArg [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ArgsMap.ArgsMap.NextArg.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ArgsMap.ArgsMap.NextArg.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.addArgument();
            }
            finally
            {
                context.setState(ArgsMap.Start);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ArgsMap.ArgsMap.NextArg.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ArgsMap.ArgsMap.NextArg.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : Default() [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ArgsMap.NextArg [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ArgsMap.ArgsMap.NextArg.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ArgsMap.ArgsMap.NextArg.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.error("Missing ',' or closing paren after argument.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ArgsMap.Error);

                if (log.isTraceEnabled())
                {
                    log.trace("BEFORE ENTRY    : ArgsMap.ArgsMap.NextArg.Entry(context) [" + context.getName() + "]");
                }

                (context.getState()).Entry(context);

                if (log.isTraceEnabled())
                {
                    log.trace("AFTER ENTRY     : ArgsMap.ArgsMap.NextArg.Entry(context) [" + context.getName() + "]");
                }
            }

            return;
        }

        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : RIGHT_PAREN(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ArgsMap.NextArg [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ArgsMap.ArgsMap.NextArg.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ArgsMap.ArgsMap.NextArg.Exit(context) [" + context.getName() + "]");
                }

            context.clearState();
            try
            {
                ctxt.addArgument();
            }
            finally
            {
                context.popState();
            }


            context.argsDone( ctxt.getArgsList());
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }

    @SuppressWarnings("serial")
    private static final class ArgsMap_Error
        extends ArgsMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ArgsMap_Error(String name, int id)
        {
            super (name, id);
        }

        protected void Entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("{", "}");
            ctxt.clearArguments();
            return;
        }

        protected void Exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {

            if (log.isTraceEnabled())
            {
                log.trace("TRANSITION   : SOURCE(token: SmcLexer.Token) [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
            {
                log.trace("LEAVING STATE   : ArgsMap.Error [" + context.getName() + "]");
            }
            if (log.isTraceEnabled())
        {
                log.trace("BEFORE EXIT     : ArgsMap.ArgsMap.Error.Exit(context) [" + context.getName() + "]");
            }

            (context.getState()).Exit(context);
            if (log.isTraceEnabled())
        {
                log.trace("AFTER EXIT      : ArgsMap.ArgsMap.Error.Exit(context) [" + context.getName() + "]");
                }

            context.popState();

            context.argsError();
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //
    }
    private void writeObject(java.io.ObjectOutputStream ostream)
        throws java.io.IOException
    {
        int size =
            (_stateStack == null ? 0 : _stateStack.size());
        int i;

        ostream.writeInt(size);

        for (i = 0; i < size; ++i)
        {
            ostream.writeInt(
                ((SmcParserState) _stateStack.get(i)).getId());
        }

        ostream.writeInt(_state.getId());

        return;
    }

    private void readObject(java.io.ObjectInputStream istream)
        throws java.io.IOException
    {
        int size;

        size = istream.readInt();

        if (size == 0)
        {
            _stateStack = null;
        }
        else
        {
            int i;

            _stateStack =
                new java.util.Stack<statemap.State>();

            for (i = 0; i < size; ++i)
            {
                _stateStack.add(i, _States[istream.readInt()]);
            }
        }

        _state = _States[istream.readInt()];

        return;
    }


	transient protected java.util.Stack<statemap.State> _stateStack;

    /**
     * Pushes the current state on top of the state stack and
     * sets the current state to {@code state}.
     * @param state The new current state.
     * @exception NullPointerException
     * if {@code state} is {@code null}.
     */
    public void pushState(statemap.State state)
    {
        if (_state == null)
        {
            throw (new NullPointerException());
        }

        if (getLog().isDebugEnabled())
        {
            getLog().debug(String.format("PUSH TO STATE   : %s [%s]",
                                     state.getName(), _name));
        }

        if (_stateStack == null)
        {
            _stateStack = new java.util.Stack<statemap.State>();
        }

        _stateStack.push(_state);
        _state = state;

        return;
    } // end of pushState(State)

    /**
     * Sets the previous state to the current state and pops
     * the top state off the stack and places it into the
     * current state.
     * if the state stack is empty.
     */
    public void popState()
    {
        if (_stateStack == null ||
            _stateStack.isEmpty() == true)
        {
            if (getLog().isDebugEnabled())
            {
                getLog().debug(
                    "POPPING ON EMPTY STATE STACK.");
            }

            throw (new RuntimeException("Empty Stack"));
        }
        else
        {
            // The pop method removes the top element
            // from the stack and returns it.
            _state = _stateStack.pop();

            if (_stateStack.isEmpty() == true)
            {
                _stateStack = null;
            }

            if (getLog().isDebugEnabled())
            {
                getLog().debug(String.format("POP TO STATE    : %s [%s]",
                                      _state.getName(), _name));
            }
        }

        return;
    } // end of popState()

    /**
     * Empties the state stack.
     */
    public void emptyStateStack()
    {
        if (_stateStack != null)
        {
            _stateStack.clear();
            _stateStack = null;
        }

        return;
    } // end of emptyStateStack()

    public boolean getDebugFlag() {
        return false;
    }

    public PrintStream getDebugStream() {
        // TODO Auto-generated method stub
        return null;
    }
}

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
